"use strict";
angular.module("vccInCall", ["ngAnimate", "ngCookies", "ngResource", "ngSanitize", "ngRoute", "ui.bootstrap", "ui.utils", "timer"]).config(["$routeProvider", "$locationProvider", function(n) {
        n.when("/api-test", {templateUrl: "views/templates/api-test-page.html"}).when("/in-call-ui", {templateUrl: "views/templates/in-call-ui-page.html"}).when("/login", {templateUrl: "views/templates/login-page.html"}).otherwise({templateUrl: "views/templates/in-call-page.html"})
    }]);
typeof String.prototype.startsWith != "function" && (String.prototype.startsWith = function(n) {
    return this.slice(0, n.length) === n
});
angular.module("vccInCall").controller("vccInCallController", ["$scope", "$rootScope", "$location", "$timeout", "$route", "vccService", function(n, t, i, r, u, f) {
        function v(n) {
            (n.isDismissable || n.hasAction) && (n.hasAction ? n.action().then(function() {
                h(n)
            }) : h(n))
        }
        function h(n) {
            n.hidden = !0;
            n.timeout && r.cancel(n.timeout);
            var t = o.indexOf(n);
            t !== -1 && o.splice(t, 1)
        }
        function y() {
            return n.controls.chat.show
        }
        function p() {
            n.activeChatMessage.hidden = !0
        }
        function l() {
            var n = $("#chatWindow"), t = n[0].scrollHeight;
            n.animate({scrollTop: t}, 1e3)
        }
        function a(t) {
            var i = n.controls[t];
            i.show = !0;
            i.timeout && r.cancel(i.timeout);
            i.autoHide && e.callers.length > 1 && (i.timeout = r(function() {
                i.show = !1
            }, 2e3))
        }
        function c() {
            a("topBar");
            a("controlBar")
        }
        function w() {
            n.controls.topBar.show = !1;
            n.controls.controlBar.show = !1
        }
        function b() {
            var n = i.search(), u = n.authTicket || n.authticket, t, r;
            if (u)
                return f.startCallWithAuthTicket(u);
            if (t = n.roomId || n.roomid, r = n.roomPassword || n.roompassword, t && r)
                return f.startCallWithRoomDetails(t, r);
            i.path("login")
        }
        var e = f.getModel(), o, s;
        n.multipleLayouts = VCC.config.multipleLayouts;
        n.localCaller = null;
        n.chatNotifications = 0;
        n.controls = {topBar: {show: !0,autoHide: !0},controlBar: {show: !0,autoHide: !0},chat: {show: !1,autoHide: !1},endCall: {show: !1,autoHide: !1}};
        n.layoutNo = 1;
        o = n.activeAlertMessages = [];
        n.activeChatMessage = null;
        s = {x: 0,y: 0};
        t.$watch("model.callers.length", function() {
            n.callerNo = e.callers.length;
            n.localCaller = e.getLocalCaller();
            e.callers.length === 1 ? c() : w()
        });
        t.$watch("model.alertMessages.length", function() {
            function f(n) {
                o.push(n);
                n.removeMessagePromise && n.removeMessagePromise.then(function() {
                    h(n)
                });
                isNaN(n.displayTimeoutInSeconds) || (n.timeout = r(function() {
                    n.timeout = null;
                    h(n)
                }, n.displayTimeoutInSeconds * 1e3))
            }
            var t, u, n, i;
            if (e.alertMessages.length !== 0) {
                for (t = e.alertMessages[e.alertMessages.length - 1], n = 0; n < o.length; n++)
                    if (i = o[n], i.type === t.type && i.messageText === t.messageText) {
                        o.splice(n, 1);
                        break
                    }
                if (u = VCC.config.messages.numAlerts, o.length < u) {
                    f(t);
                    return
                }
                for (n = 0; n < o.length; n++)
                    if (i = o[n], i.type === e.getModelDefinition().alertMessageTypes.standard) {
                        o.splice(n, 1);
                        break
                    }
                (o.length < u || t.type !== e.getModelDefinition().alertMessageTypes.standard) && f(t)
            }
        });
        t.$watch("model.chatMessages.length", function() {
            function i() {
                var i = e.chatMessages[e.chatMessages.length - 1], t = n.activeChatMessage = angular.extend({}, i);
                t.hidden = !1;
                t.timeout = r(function() {
                    t.hidden = !0
                }, t.displayTimeoutInSeconds * 1e3)
            }
            if (e.chatMessages.length !== 0)
                if (y() ? (n.chatNotifications = 0, r(l, 100)) : n.chatNotifications = n.chatNotifications + 1, n.activeChatMessage) {
                    var t = n.activeChatMessage;
                    r.cancel(t.timeout);
                    t.hidden = !0;
                    t.timeout = r(i, 100)
                } else
                    i()
        });
        n.setPreferredSpeaker = function(n, t) {
            n.isLocalCaller || f.setPreferredSpeaker(n, t)
        };
        n.activeChatMessageClicked = function() {
            p()
        };
        n.alertMessageClicked = function(n) {
            v(n)
        };
        n.showInCallControls = function() {
            c()
        };
        n.showInCallControlsOnMouseMove = function(n) {
            (s.x !== n.offsetX || s.y !== n.offsetY) && (s.x = n.offsetX, s.y = n.offsetY, c())
        };
        n.toggleMic = function() {
            f.toggleMic()
        };
        n.toggleVideo = function() {
            f.toggleVideo()
        };
        n.leaveCall = function() {
            f.leaveCall()
        };
        n.toggleScreenShare = function() {
            f.toggleScreenShare()
        };
        n.sendChatMessage = function(n) {
            f.sendChatMessage(n)
        };
        n.toggleChat = function() {
            n.controls.chat.show = !n.controls.chat.show;
            n.controls.chat.show && (n.chatNotifications = 0, r(l, 100))
        };
        n.closeChat = function() {
            n.controls.chat.show = !1
        };
        n.toggleLayout = function() {
            n.layoutNo = n.layoutNo < 2 ? n.layoutNo + 1 : 1
        };
        b()
    }]);
angular.module("vccInCall").controller("apiTestController", ["$scope", "$log", "vccService", function(n, t, i) {
        n.model = i.getModel();
        n.activeView = null;
        n.loginDetails = {authticket: "a1890541-bd31-4549-89d9-587f7b7bf239"};
        n.roomDetails = {id: "r2804",password: "found42"};
        n.submitStartCallWithAuthTicket = function(n) {
            t.debug("submitStartCallWithAuthTicket authTicket: " + n);
            i.startCallWithAuthTicket(n)
        };
        n.submitStartCallWithRoomDetails = function(n, r) {
            t.debug("submitStartCallWithRoomDetails roomId: " + n + " roomPassword: " + r);
            i.startCallWithRoomDetails(n, r)
        }
    }]);
angular.module("vccInCall").controller("inCallUiController", ["$scope", "$timeout", function(n, t) {
        n.controlBarShown = !0;
        t(function() {
            n.controlBarShown = !1
        }, 7e3);
        n.topBarShown = !0;
        t(function() {
            n.topBarShown = !1
        }, 7e3);
        n.videoLoading = !0;
        t(function() {
            n.videoLoading = !1
        }, 3e3)
    }]);
angular.module("vccInCall").controller("vccLoginController", ["$scope", "$http", "$location", function(n, t, i) {
        n.vccLogin = {};
        n.loginError = !1;
        n.logInToVCC = function(r) {
            var u = r.roomId, f = r.roomPassword;
            t.get(VCC.config.apiServerUrl + "/api/webrtc/LoginWithRoomDetails.ashx", {params: {roomId: u,roomPassword: f}}).success(function(t) {
                t === "Invalid Request" ? n.loginError = !0 : i.url("in-call?roomId=" + u + "&roomPassword=" + f)
            })
        }
    }]);
angular.module("vccInCall").factory("VCCInCallModel", ["$sce", "$log", function(n) {
        return function() {
            function u(n) {
                return n = n || {}, {callerId: n.callerId || "",name: n.name || "",avatarUrl: n.avatarUrl || "",isMuted: !1,isHidden: !1,isCurrentlySpeaking: !1,isPreferredSpeaker: !1,isLocalCaller: n.isLocalCaller || !1,cameraStream: n.cameraStream || null,screenStream: n.screenStream || null}
            }
            function f() {
                for (var n = 0; n < t.length; n++)
                    if (t[n].isLocalCaller)
                        return t[n];
                return null
            }
            function e(n) {
                for (var i = 0; i < t.length; i++)
                    if (t[i].callerId === n)
                        return t[i];
                return null
            }
            function o(n) {
                for (var r, i = 0; i < t.length; i++)
                    t[i].callerId === n && (r = i);
                r && t.splice(r, 1)
            }
            function s(n) {
                n = n || {};
                var t = new Date, i = VCC.config.messages.displayInSeconds.chat;
                return {callerId: n.callerId,callerName: n.callerName,message: n.message,displayTimeoutInSeconds: i,timestamp: t.toISOString(),messageTime: moment(t).format("HH:mm")}
            }
            function h(t) {
                t = t || {};
                var u = new Date, r = t.type || i.alertMessageTypes.standard, f = VCC.config.messages.displayInSeconds[r.style];
                return {message: n.trustAsHtml(t.message),messageText: t.message,type: r,isDismissable: !t.removeMessagePromise,removeMessagePromise: t.removeMessagePromise,action: t.action,hasAction: angular.isFunction(t.action),displayTimeoutInSeconds: parseFloat(f),timestamp: u.toISOString()}
            }
            function c(n) {
                var t = [];
                return angular.forEach(r, function(i) {
                    i.type === n && t.push(i)
                }), t
            }
            var i = {alertMessageTypes: {standard: {style: "standard"},error: {style: "error"},escalation: {style: "escalation"},status: {style: "status"}},alertMessageCategories: {mediaDevice: {id: "mediaDevice"},notificationFromServer: {id: "notificationFromServer"}}}, t = [], r = [];
            return {getModelDefinition: function() {
                    return angular.extend({}, i)
                },conference: {conferenceId: "",name: "",inviteRoomId: "",invitePassword: "",inviteUrl: "",inviteAuthorisedUrl: "",logoUrl: "",callHelpMessage: "",isFinished: !1,callStartTime: null,isCallStartTimeReady: !1,isServiceCentreCall: !1},callers: t,createCaller: function(n) {
                    return u(n)
                },getLocalCaller: function() {
                    return f()
                },getCaller: function(n) {
                    return e(n)
                },removeCaller: function(n) {
                    return o(n)
                },removeAllCallers: function() {
                    t = []
                },chatMessages: [],createChatMessage: function(n) {
                    return s(n)
                },alertMessages: r,createAlertMessage: function(n) {
                    return h(n)
                },getAlertMessagesByType: function(n) {
                    return c(n)
                },preferredSpeaker: null,preferredVideo: null,cameraTiles: [],screenTiles: [],canShowScreenSharingButton: !1}
        }
    }]);
angular.module("vccInCall").factory("configService", [function() {
        return {}
    }]);
angular.module("vccInCall").service("storageService", [function() {
        var n = null;
        if (window.localStorage !== undefined)
            n = window.localStorage;
        else
            throw "session Storage not supported";
        return {saveObject: function(t, i) {
                n.setItem(t, JSON.stringify(i))
            },saveValue: function(t, i) {
                n.setItem(t, i)
            },fetchObject: function(t) {
                var i = n[t];
                return i === undefined || i.length === 0 || i === "undefined" ? null : JSON.parse(i)
            },fetchValue: function(t) {
                var i = n[t];
                return i === undefined ? null : i
            },remove: function(t) {
                n.removeItem(t)
            },clearAll: function() {
                n.clear()
            }}
    }]);
angular.module("vccInCall").service("constantsService", [function() {
        var n = "abcd";
        return {getSomeConstant: function() {
                return n
            }}
    }]);
angular.module("vccInCall").factory("vccService", ["$q", "$log", "$http", "$timeout", "$interval", "$window", "$rootScope", "$location", "constantsService", "configService", "storageService", "VCCInCallModel", function(n, t, i, r, u, f, e, o, s, h, c, l) {
        function wt() {
            return a
        }
        function bt() {
            var t = n.defer(), i, u;
            return v.scriptsLoaded ? t.resolve() : (i = ["/v3/javascript/aartc-v5.js", "/v3/javascript/sipjs.helper.js", "/v3/javascript/webrtc.stats.js", "/signalr/hubs"], u = [], angular.forEach(i, function(n) {
                jQuery.getScript(y.apiServerUrl + n, function() {
                    u.push(n);
                    u.length === i.length && r(function() {
                        v.scriptsLoaded = !0;
                        t.resolve()
                    })
                })
            })), t.promise
        }
        function kt(n) {
            t.debug("Caller details received:");
            t.debug(n);
            var r = dt(n), i = a.getCaller(n.WebSocketId);
            i && (i.id = n.callerId, i.name = n.Name, i.avatarUrl = n.AvatarImageUrl, i.isHidden = n.IsVideoStopped, i.isMuted = n.IsAudioStopped, !i.isLocalCaller && r && (a.alertMessages.push(a.createAlertMessage({message: i.name + " has joined the call"})), rt.volume = .3, rt.play()))
        }
        function dt(n) {
            var t = a.getCaller(n.WebSocketId);
            return t && t.name === ""
        }
        function ft(n, i, r) {
            t.debug("Adding caller " + n + " to the model - isLocalCaller " + r);
            a.callers.push(a.createCaller({callerId: n,cameraStream: i,isLocalCaller: r}));
            r || vt(n, !0, !1);
            $.connection.conferenceHub.server.getUserDetails(n)
        }
        function et(n) {
            var i = a.getCaller(n);
            i ? (t.debug("Removing caller " + n), a.removeCaller(n), yt(n, !0, !0), a.alertMessages.push(a.createAlertMessage({message: i.name + " has left the call"})), ut.volume = .3, ut.play()) : t.error("Attempting to remove caller that no longer exists " + n)
        }
        function gt(n) {
            t.debug("chat message received:");
            t.debug(n);
            a.chatMessages.push(a.createChatMessage({callerId: n.SenderPersonId,callerName: n.SenderName,message: n.Message}));
            it.volume = .3;
            it.play()
        }
        function ni(t) {
            ot();
            p = n.defer();
            a.alertMessages.push(a.createAlertMessage({message: t,type: a.getModelDefinition().alertMessageTypes.status,removeMessagePromise: p.promise}))
        }
        function ot() {
            p && (p.resolve(), p = null)
        }
        function ti(i, u) {
            var f = $("<div/>").html(u).text();
            t.debug("_showServiceGuestIdleMessage(" + i + ", " + f + " ) called");
            b = r(function() {
                b = null;
                t.debug("_showServiceGuestIdleMessage timed out after " + i + " seconds");
                a.callers.length <= 1 && (w = n.defer(), a.alertMessages.push(a.createAlertMessage({message: f,type: a.getModelDefinition().alertMessageTypes.escalation,removeMessagePromise: w.promise})))
            }, i * 1e3)
        }
        function ii() {
            b && (r.cancel(b), b = null);
            w && (w.resolve(), w = null)
        }
        function ri() {
            t.debug("_getIceServers() called");
            var r = n.defer();
            return i.get(y.apiServerUrl + "/api/webrtc/GetTURNHandler.ashx", {params: {authticket: v.authenticationTicket}}).success(function(n) {
                var u;
                t.debug(n);
                var i = n.turnUrl, f = n.credential, e = n.username;
                if (f && e) {
                    v.iceServers = [];
                    for (u in i)
                        i[u].indexOf("stun") === 0 ? v.iceServers.push({url: i[u]}) : v.iceServers.push({url: i[u],credential: f,username: e})
                } else
                    v.iceServers.push({url: i});
                t.debug("_getIceServers() completed");
                r.resolve()
            }).error(function(n) {
                t.error(n);
                t.error("Could not connect to TURN server so fallback to Google default");
                v.iceServers = [{url: "stun.l.google.com:19302"}];
                t.debug("_getIceServers() completed with fallback");
                r.resolve()
            }), r.promise
        }
        function ui() {
            t.debug("_registerConferenceHub() called");
            var i = n.defer();
            try {
                $.connection.hub.url = VCC.config.apiServerUrl + "/signalr";
                $.connection.hub.logging = VCC.config.isDebugMode;
                $.connection.conferenceHub.client.receiveChat = function(n) {
                    r(function() {
                        gt(n)
                    })
                };
                $.connection.conferenceHub.client.newCallerDetails = function(n) {
                    r(function() {
                        kt(n)
                    })
                };
                $.connection.conferenceHub.client.userDisconnected = function(n) {
                    r(function() {
                        et(n)
                    })
                };
                $.connection.conferenceHub.client.disconnect = function(n) {
                    t.debug("conferenceHub.client.disconnect() called : " + n);
                    r(function() {
                        d();
                        var t = a.getModelDefinition().alertMessageTypes.error;
                        a.alertMessages.push(a.createAlertMessage({message: n,type: t,action: g}))
                    });
                    r(g, 5e3)
                };
                $.connection.conferenceHub.client.queueStatusUpdate = function(n, t) {
                    r(function() {
                        ni(n, t)
                    })
                };
                $.connection.conferenceHub.client.showServiceGuestIdleMessage = function(n, t) {
                    r(function() {
                        ti(n, t)
                    })
                };
                $.connection.conferenceHub.client.registered = function() {
                    t.debug("_registerConferenceHub() completed");
                    i.resolve()
                };
                $.connection.conferenceHub.client.initiateRecording = function(n) {
                    t.debug(n);
                    sipJsManager.session && sipJsManager.hangup();
                    var i = a.getLocalCaller();
                    sipJsManager.call(n.BridgeId, n.ConfPassword, n.SipServerUrl, v.iceServers, v.personId, i.cameraStream)
                };
                $.connection.conferenceHub.client.terminateRecording = function() {
                    sipJsManager.hangup()
                };
                $.connection.conferenceHub.client.showTransferredCallerMessage = function(n) {
                    r(function() {
                        a.alertMessages.push(a.createAlertMessage({message: n}))
                    })
                };
                $.connection.conferenceHub.client.providerJoined = function() {
                    r(function() {
                        ot()
                    })
                };
                $.connection.hub.start({transport: ["longPolling", "foreverFrame", "serverSentEvents"]}).done(function() {
                    v.signalrConnectionId = $.connection.hub.id;
                    var n = {personId: v.personId,connectionId: v.signalrConnectionId,webSocketId: v.webRtcSocketId,conferenceId: a.conference.conferenceId,authenticationTicket: v.authenticationTicket};
                    $.connection.conferenceHub.server.register(n)
                });
                $.connection.hub.disconnected(function() {
                    $.connection.hub.lastError && (t.error(error), t.error("SignalR connection lost"));
                    a.conference.isFinished = !0
                })
            } catch (error) {
                t.error(error);
                t.error("_registerConferenceHub() completed with error");
                a.conference.isFinished = !0;
                i.reject(error)
            }
            return i.promise
        }
        function fi() {
            var i, u;
            t.debug("_getUserMedia() called");
            i = n.defer();
            r(function() {
                var n = a.getModelDefinition().alertMessageTypes.error, t = "We are unable to access your local camera and/or microphone.<br/>" + a.conference.callHelpMessage;
                a.alertMessages.push(a.createAlertMessage({message: t,type: n,removeMessagePromise: i.promise}));
                ga("send", {hitType: "event",eventCategory: "WebRTC",eventAction: "Media device(s) not ready",eventLabel: v.personId.toString()})
            }, 3e3);
            u = aartc.captureconfig(y.mediaCaptureParam).toConstraints();
            aartc.media({constraints: u,plugins: [aartc.pluginNictaIos]}).once("capture", function(n) {
                t.debug("Received stream back from aartc.media:");
                t.debug(n.id);
                n ? r(function() {
                    ft(v.webRtcSocketId, n, !0);
                    t.debug("_getUserMedia() completed");
                    i.resolve()
                }) : (t.error(error), t.error("_getUserMedia() completed with error"), a.conference.isFinished = !0, i.reject())
            });
            return i.promise
        }
        function ei() {
            var i, r;
            t.debug("_registerRtcSwitchboard() called");
            i = n.defer();
            v.aaSignalingServerConnection = $.hubConnection(v.aaSignalingServerUrl);
            r = v.aaSignalingServerConnection.createHubProxy("signalingHub");
            r.on("receive", function(n) {
                t.debug("received message in client: " + n);
                v.aaSignaller.process(n)
            });
            return v.aaSignalingServerConnection.qs = {token: v.authenticationTicket}, v.aaSignalingServerConnection.start({transport: ["longPolling", "foreverFrame", "serverSentEvents"]}).done(function() {
                var u = {send: function(n) {
                        t.debug("Sending message: " + n);
                        r.invoke("send", n)
                    },receive: function(n) {
                        t.debug("Received message: " + n);
                        v.aaSignaller.process(n)
                    },connected: !0}, n;
                v.aaSignaller = aartc.quickconnect(u, {plugins: [aartc.pluginNictaIos],room: a.conference.conferenceId,iceServers: v.iceServers,id: v.webRtcSocketId,disableHeartbeat: !0,debug: VCC.config.isDebugMode,reactive: y.isRtcIoReativeMode});
                n = a.getLocalCaller();
                v.aaSignaller.broadcast(n.cameraStream).on("call:started", function(n, i) {
                    t.debug("call started: ", n);
                    var r = i.getRemoteStreams()[0];
                    t.debug("Added remote caller to model");
                    ft(n, r, !1);
                    ii()
                }).on("call:ended", function(n) {
                    t.debug("call ended: ");
                    t.debug(n);
                    et(n)
                }).on("stream:added", function(n, t) {
                    lt(n, t)
                }).on("stream:removed", function(n, t) {
                    at(n, t)
                });
                t.debug("_registerRtcSwitchboard() completed");
                i.resolve()
            }).fail(function(n) {
                t.error("Error: " + n);
                t.debug("_registerRtcSwitchboard() completed with error");
                a.conference.isFinished = !0;
                i.reject(n)
            }), i.promise
        }
        function oi(r) {
            t.debug("_startCallWithAuthTicket() called");
            var u = n.defer();
            return i.get(y.apiServerUrl + "/api/webrtc/LoginWithAuthTicket.ashx", {params: {authTicket: r}}).success(function(n) {
                t.debug(n);
                v.personId = n.personId;
                v.webRtcSocketId = n.webRtcSocketId;
                v.authenticationTicket = n.authenticationTicket;
                v.aaSignalingServerUrl = n.aaSignalingServerUrl;
                v.videoCallStatsCollectorIntervalSecs = n.videoCallStatsCollectorIntervalSecs;
                a.conference.conferenceId = n.conferenceId;
                a.conference.name = n.conferenceName;
                a.conference.logoUrl = n.conferenceLogoUrl;
                a.conference.callHelpMessage = n.callHelpMessage;
                a.conference.callStartTime = new Date - n.secondsFromSessionStart * 1e3;
                a.conference.isServiceCentreCall = n.isServiceCentreCall;
                a.canShowScreenSharingButton = !nt() && !n.isServiceCentreCall;
                n.secondsFromSessionStart >= 0 && (a.conference.isCallStartTimeReady = !0);
                st().then(function() {
                    t.debug("_startCallWithAuthTicket() completed");
                    u.resolve()
                })
            }).error(function(n) {
                t.error(n);
                t.debug("_startCallWithAuthTicket() completed with error");
                u.reject(n)
            }), u.promise
        }
        function si(r, u) {
            t.debug("_startCallWithRoomDetails() called");
            var f = n.defer();
            return i.get(VCC.config.apiServerUrl + "/api/webrtc/LoginWithRoomDetails.ashx", {params: {roomId: r,roomPassword: u}}).success(function(n) {
                t.debug(n);
                v.personId = n.personId;
                v.webRtcSocketId = n.webRtcSocketId;
                v.authenticationTicket = n.authenticationTicket;
                v.aaSignalingServerUrl = n.aaSignalingServerUrl;
                v.videoCallStatsCollectorIntervalSecs = n.videoCallStatsCollectorIntervalSecs;
                a.conference.conferenceId = n.conferenceId;
                a.conference.name = n.conferenceName;
                a.conference.logoUrl = n.conferenceLogoUrl;
                a.conference.callHelpMessage = n.callHelpMessage;
                a.conference.callStartTime = new Date - n.secondsFromSessionStart * 1e3;
                a.conference.isServiceCentreCall = n.isServiceCentreCall;
                a.canShowScreenSharingButton = !nt() && !n.isServiceCentreCall;
                n.secondsFromSessionStart >= 0 && (a.conference.isCallStartTimeReady = !0);
                st().then(function() {
                    t.debug("_startCallWithRoomDetails() completed");
                    f.resolve()
                })
            }).error(function(n) {
                t.error(n);
                t.debug("_startCallWithRoomDetails() completed with error");
                f.reject(n)
            }), f.promise
        }
        function hi(n) {
            return n.cameraStream.audioTracks ? n.cameraStream.audioTracks[0] : n.cameraStream.getAudioTracks() ? n.cameraStream.getAudioTracks()[0] : null
        }
        function ci(n) {
            return n.cameraStream.videoTracks ? n.cameraStream.videoTracks[0] : n.cameraStream.getVideoTracks() ? n.cameraStream.getVideoTracks()[0] : null
        }
        function st() {
            var i, r, u;
            if (t.debug("_startCall() called"), i = n.defer(), !v.authenticationTicket) {
                t.error("Un-Authorized");
                r = a.getModelDefinition().alertMessageTypes.error;
                u = "Your call has ended. Please close the window and try again.";
                a.alertMessages.push(a.createAlertMessage({message: u,type: r}));
                t.debug("_startCall() completed with error");
                i.reject("Un-Authorized");
                return
            }
            return bt().then(ri).then(ui).then(fi).then(ei).then(function() {
                pi();
                yi();
                ir();
                ga("send", {hitType: "event",eventCategory: "WebRTC",eventAction: "Call Successful",eventLabel: v.personId.toString()});
                t.debug("_startCall() completed");
                i.resolve()
            }), i.promise
        }
        function li(n) {
            $.connection.conferenceHub.server.chat({senderPersonId: v.webRtcSocketId,senderName: a.getLocalCaller().name,message: n})
        }
        function ai() {
            var t = a.getLocalCaller(), n = hi(t);
            n && (n.enabled = !n.enabled, n.enabled ? $.connection.conferenceHub.server.startAudio(t.callerId) : $.connection.conferenceHub.server.stopAudio(t.callerId))
        }
        function vi() {
            var t = a.getLocalCaller(), n = ci(t);
            n && (n.enabled = !n.enabled, n.enabled ? $.connection.conferenceHub.server.startVideo(t.callerId) : $.connection.conferenceHub.server.stopVideo(t.callerId))
        }
        function d() {
            t.debug("_closeCall() called");
            ht();
            a.conference.isFinished = !0;
            try {
                t.debug("close the connection to SIP recording server");
                $.connection.conferenceHub.client.terminateRecording()
            } catch (n) {
                t.debug(n)
            }
            var i = a.getLocalCaller();
            try {
                t.debug("end video call for user");
                $.connection.conferenceHub.server.disconnectUser(i.callerId)
            } catch (n) {
                t.debug(n)
            }
            try {
                t.debug("stop the timer on page");
                $("section.userInfo").find("timer")[0].stop()
            } catch (n) {
                t.debug(n)
            }
            try {
                t.debug("disconnecting from rtcio signaller");
                v.aaSignaller.close()
            } catch (n) {
                t.debug(n)
            }
            try {
                t.debug("stoping the local media access");
                i.cameraStream && i.cameraStream.stop()
            } catch (n) {
                t.debug(n)
            }
            try {
                t.debug("remove all callers");
                a.removeAllCallers()
            } catch (n) {
                t.debug(n)
            }
            try {
                t.debug("closing signalr connection");
                $.connection.hub.stop()
            } catch (n) {
                t.debug(n)
            }
        }
        function g() {
            return t.debug("_closeWindow() called"), window.close(), n.defer().promise
        }
        function yi() {
            u(function() {
                logBandwidthStats(v.aaSignaller, v.webRtcSocketId)
            }, v.videoCallStatsCollectorIntervalSecs * 1e3)
        }
        function pi() {
            (t.debug("_registerConnectionCheck() called"), v.registerConnectionCheckInterval) || (v.registerConnectionCheckInterval = u(function() {
                bi().then(function(n) {
                    if (n.valid)
                        t.debug("Connection is still valid");
                    else {
                        t.error("Connection failed with error: " + n.message);
                        ht();
                        d();
                        var i = a.getModelDefinition().alertMessageTypes.error;
                        a.alertMessages.push(a.createAlertMessage({message: "Your call has been disconnected - click here to repair the call",type: i,action: wi}))
                    }
                })
            }, 5e3))
        }
        function ht() {
            u.cancel(v.registerConnectionCheckInterval);
            v.registerConnectionCheckInterval = null
        }
        function wi() {
            return f.location.reload(), n.defer().promise
        }
        function bi() {
            t.debug("_isConnectionValid() called");
            var i = n.defer();
            return a.conference.isFinished && i.resolve({valid: !1,message: "Conference call has already been closed"}), ki() || (ga("send", {hitType: "event",eventCategory: "WebRTC",eventAction: "Media device(s) not ready",eventLabel: v.personId.toString()}), i.resolve({valid: !1,message: "Local stream unavailable"})), di() || (ga("send", {hitType: "event",eventCategory: "WebRTC",eventAction: "Conf Failed",eventLabel: v.personId.toString()}), i.resolve({valid: !1,message: "Disconnected from signaling server"})), gi() || (ga("send", {hitType: "event",eventCategory: "WebRTC",eventAction: "RTC Failed",eventLabel: v.personId.toString()}), i.resolve({valid: !1,message: "Disconnected from conference hub"})), nr().then(function(n) {
                n ? i.resolve({valid: !0}) : i.resolve({valid: !1,message: "User is no longer in call in AA DB"})
            }), i.promise
        }
        function ki() {
            var n = a.getLocalCaller();
            return n && n.cameraStream
        }
        function di() {
            return v.aaSignalingServerConnection && v.aaSignalingServerConnection.state !== 4
        }
        function gi() {
            return $.connection.hub.state !== 4
        }
        function nr() {
            t.debug("_isUserStillInCall() called");
            var r = n.defer();
            return i.get(VCC.config.apiServerUrl + "/api/webrtc/VerifyVidyoCall.ashx", {params: {authticket: v.authenticationTicket}}).success(function(n) {
                var i = n.toLowerCase() === "true";
                t.debug("_isUserStillInCall() completed with result: " + i);
                r.resolve(i)
            }).error(function() {
                t.error("_isUserStillInCall() completed with error");
                r.resolve(!0)
            }), r.promise
        }
        function tr() {
            var n = a.getLocalCaller();
            n.screenStream ? (v.aaSignaller.removeStream(n.screenStream), at(n.callerId, n.screenStream)) : v.isScreenShareChromeExtensionInstalled ? ct() : rr()
        }
        function ir() {
            var i, n;
            if (t.debug("_detectScreenShareExtension() called"), !v.screenShareChromeExtensionId) {
                t.debug("TODO: Hide the Share Screen button bcz extension id is not defined for current portal");
                return
            }
            i = "chrome-extension://" + v.screenShareChromeExtensionId + "/icon48.png";
            t.debug("trying to load an image from extension resources = " + i);
            n = new Image;
            n.src = i;
            n.onload = function() {
                v.isScreenShareChromeExtensionInstalled = !0
            };
            n.onerror = function() {
                v.isScreenShareChromeExtensionInstalled = !1
            }
        }
        function rr() {
            t.debug("_installScreenShareExtension() called");
            var n = "https://chrome.google.com/webstore/detail/" + v.screenShareChromeExtensionId;
            return t.debug("url = " + n), chrome.webstore.install(n, ur, fr)
        }
        function ur() {
            t.debug("_extensionInstallSuccessCallback() called");
            ct()
        }
        function fr() {
            t.debug("_extensionInstallFailureCallback() called");
            t.debug('TODO : Disable "Start Sharing" button and inform the user')
        }
        function ct() {
            console.log("_startShareScreen() called");
            var n = a.getLocalCaller();
            aartc.screenshare(function(i, r) {
                if (i)
                    return t.debug("Could not capture window: ", i);
                t.debug("Constraints generated for screen share: ", r);
                aartc.media(r).capture(r, function(t) {
                    v.aaSignaller.addStream(t);
                    lt(n.callerId, t)
                })
            })
        }
        function lt(n, i) {
            var r = a.getCaller(n);
            t.debug("addScreenStream called for id = " + r.callerId);
            r && r.cameraStream && r.cameraStream.id != i.id && (r.screenStream = i, r.isLocalCaller || vt(n, !1, !0))
        }
        function at(n, i) {
            var r = a.getCaller(n);
            r && r.screenStream && r.screenStream.id == i.id && (t.debug("removeScreenStream called with secondary stream for callerid = " + r.callerId), r.screenStream = null, r.isLocalCaller || yt(n, !1, !0))
        }
        function nt() {
            var n = {Android: function() {
                    return navigator.userAgent.match(/Android/i)
                },BlackBerry: function() {
                    return navigator.userAgent.match(/BlackBerry/i)
                },iOS: function() {
                    return navigator.userAgent.match(/iPhone|iPad|iPod/i)
                },Opera: function() {
                    return navigator.userAgent.match(/Opera Mini/i)
                },Windows: function() {
                    return navigator.userAgent.match(/IEMobile/i)
                },any: function() {
                    return n.Android() || n.BlackBerry() || n.iOS() || n.Opera() || n.Windows()
                }};
            return n.any() ? !0 : !1
        }
        function vt(n, t, i) {
            var r = a.getCaller(n);
            t && a.cameraTiles.push(r);
            i && (a.preferredVideo == "camera" && a.screenTiles.length === 0 ? k(r, "screen") : a.screenTiles.push(r));
            pt()
        }
        function yt(n, t, i) {
            t && angular.forEach(a.cameraTiles, function(t, i) {
                t.callerId === n && a.cameraTiles.splice(i, 1)
            });
            i && angular.forEach(a.screenTiles, function(t, i) {
                t.callerId === n && a.screenTiles.splice(i, 1)
            });
            pt()
        }
        function pt() {
            er();
            a.preferredSpeaker == null && (a.screenTiles && a.screenTiles.length > 0 ? k(a.screenTiles[0], "screen") : a.cameraTiles && a.cameraTiles.length > 0 && k(a.cameraTiles[0], "camera"))
        }
        function er() {
            a.preferredSpeaker && a.callers.indexOf(a.preferredSpeaker) === -1 && (a.preferredSpeaker = null);
            a.preferredSpeaker && a.preferredVideo == "screen" && a.preferredSpeaker.screenStream == null && (a.preferredSpeaker = null)
        }
        function k(n, t) {
            var i = a.preferredSpeaker, u = a.preferredVideo, r;
            i && (u == "screen" ? a.screenTiles.unshift(i) : u == "camera" && a.cameraTiles.unshift(i), i.isPreferredSpeaker = !1);
            n.isPreferredSpeaker = !0;
            a.preferredSpeaker = n;
            a.preferredVideo = t;
            t == "camera" ? (r = a.cameraTiles.indexOf(n), a.cameraTiles.splice(r, 1)) : t == "screen" && (r = a.screenTiles.indexOf(n), a.screenTiles.splice(r, 1))
        }
        var y = VCC.config, tt = e, it = document.getElementById("chatMessage"), rt = document.getElementById("callerAdded"), ut = document.getElementById("callerLeft"), a = tt.model = new l, v = tt.connection = {personId: "",webRtcSocketId: "",authenticationTicket: "",aaSignalingServerUrl: "",aaSignalingServerConnection: null,signalrConnectionId: "",iceServers: [],aaSignaller: null,registerConnectionCheckInterval: null,videoCallStatsCollectorIntervalSecs: 30,scriptsLoaded: !1,screenShareChromeExtensionId: "ffmglcfbbhidemlkdgbpdcadbmdffgbc",isScreenShareChromeExtensionInstalled: !1}, p = null, w = null, b = null;
        return {getModel: function() {
                return wt()
            },startCallWithAuthTicket: function(n) {
                return oi(n)
            },startCallWithRoomDetails: function(n, t) {
                return si(n, t)
            },sendChatMessage: function(n) {
                return li(n)
            },toggleMic: function() {
                return ai()
            },toggleVideo: function() {
                return vi()
            },leaveCall: function() {
                d();
                g()
            },toggleScreenShare: function() {
                tr()
            },isMobileBrowser: function() {
                return nt()
            },setPreferredSpeaker: function(n, t, i) {
                k(n, t, i)
            }}
    }]);
angular.module("vccInCall").directive("callerVideo", [function() {
        return {template: '<video><span class="mute" ng-if="caller.isMuted"><\/span><\/video>',restrict: "E",replace: !0,scope: {caller: "="},link: function(n, t) {
                n.$watch("caller", function(n) {
                    if (n.cameraStream) {
                        var i = t[0];
                        aartc.media({plugins: [aartc.pluginNictaIos],stream: n.cameraStream,muted: n.isLocalCaller}).render(i)
                    }
                });
                n.$watch("caller.isHidden", function(n) {
                    n ? t.addClass("minHeight") : t.removeClass("minHeight")
                })
            }}
    }]);
angular.module("vccInCall").directive("callerScreen", [function() {
        return {template: "<video><\/video>",restrict: "E",replace: !0,scope: {caller: "="},link: function(n, t) {
                n.$watch("caller.screenStream", function(n) {
                    if (n) {
                        var i = t[0];
                        aartc.media({plugins: [aartc.pluginNictaIos],stream: n}).render(i)
                    }
                })
            }}
    }]);
angular.module("vccInCall").filter("truncateTo", ["limitToFilter", function(n) {
        return function(t, i) {
            var r = n(t, i);
            return r.length < t.length ? r + " ..." : r
        }
    }]);
angular.module("vccInCall").filter("reverse", function() {
    return function(n) {
        return n.slice().reverse()
    }
});
